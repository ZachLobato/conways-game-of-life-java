package com.zachlobato.gameoflife;

import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JApplet;

public class Simulator extends JApplet implements MouseListener {

	private static final long serialVersionUID = 817526540227405637L;
	Image backBuffer;
	Graphics backg;
	Timer timer = new Timer();
	TimerTask task = new MyTimerTask();
	World world = generatesSeedWorld();
	
	private class MyTimerTask extends TimerTask{
		public void run(){
			world = simulateGeneration(world);
			repaint();
		}
	}
	
	public void init(){
		backBuffer = createImage(this.getWidth(), this.getHeight());
		
		this.addMouseListener(this);
		
		timer.schedule(task, 0, 16);
	}
	
	public void paint(Graphics g){
		update(g);
	}
	
	public void update(Graphics g){
		
	}
	

	public void simulate(int numberOfGenerations) {
		// generateSeedWorld
		World seedWorld = generatesSeedWorld();
		
		// outputWorld to Screen
		outputWorld(seedWorld);
								
		// outputWorld numberOfGenerations times
		World world = seedWorld;
		for (int generations = numberOfGenerations; generations > 0; generations--){
			
			world = simulateGeneration(world);
			outputWorld(world);
		}		
	}

	protected World generatesSeedWorld() {
		// createRandomSizedWorld	
		// populateWorldWithCells
		
		World staticWorld = new World(new Coordinate(5,5), 5, 3);
		
		staticWorld.activateCell(1, 1);
		staticWorld.activateCell(2, 1);
		staticWorld.activateCell(3, 1);
				
		return staticWorld;
	}

	protected void outputWorld(World world) {		
		// mapWorldToOutput
	}

	protected World simulateGeneration(World oldWorld) {
		// createReplacementWorld
		World newWorld = createReplacementWorld(oldWorld);
		
		// populateReplacementWorldGeneration
		populateReplacementWorld(oldWorld, newWorld);
		
		// contractWorld		
		newWorld.contractWorld();
		
		return newWorld;
	}

	/**
	 * Generates a new empty replacement world of the correct (expanded if necessary)
	 * size based on the oldWorld. This will be used to populate the next generation
	 * of cells.
	 * 
	 * @param oldWorld
	 * @return
	 */
	public World createReplacementWorld(World oldWorld) {
		boolean topExpands, bottomExpands, leftExpands, rightExpands;
		topExpands = bottomExpands = leftExpands = rightExpands = false;	
		
		// Check top row
		// Check bottom row		
		for (int x = 0; x < oldWorld.width; x++){
			if (oldWorld.getActiveNeighbors(x, 0)==3){
				topExpands = true;
			}
			if (oldWorld.getActiveNeighbors(x, oldWorld.height-1)==3){
				bottomExpands = true;
			}
		}
		
		// Check left column		
		// Check right column
		for (int y = 0; y < oldWorld.height; y++){
			if (oldWorld.getActiveNeighbors(0, y)==3){
				leftExpands = true;
			}
			if (oldWorld.getActiveNeighbors(oldWorld.width-1, y)==3){
				rightExpands = true;
			}
		}
		
		Coordinate newTopLeft = new Coordinate(oldWorld.topLeft.x, oldWorld.topLeft.y);
		int newWidth = oldWorld.width;
		int newHeight = oldWorld.height;
		
		if (topExpands){
			newTopLeft.y += 1;
			newHeight += 1;
		}
		if (bottomExpands){
			newHeight += 1;
		}
		if (leftExpands){
			newTopLeft.x -= 1;
			newWidth += 1;
		}
		if (rightExpands){
			newWidth += 1;
		}
		
		return new World(newTopLeft, newWidth, newHeight);
	}

	/**
	 * Takes a world generated by createReplacementWorld and populates it
	 * with the oldWorld's nextGeneration of values.
	 * 
	 * @param oldWorld
	 * @param newWorld
	 */
	public void populateReplacementWorld(World oldWorld, World newWorld) {
		int xOffset = oldWorld.topLeft.x -  newWorld.topLeft.x;
		int yOffset = newWorld.topLeft.y - oldWorld.topLeft.y;
		
		int neighborCount = 0;
		for (int x = 0; x < oldWorld.width; x++){
			for (int y = 0; y < oldWorld.height; y++){
				newWorld.setCellValue(x + xOffset, y + yOffset, oldWorld.getCellValue(x,y));
								
				neighborCount = oldWorld.getActiveNeighbors(x, y);
				
				switch (neighborCount) {
				// Cell Inactive
				case 0:
				case 1:
					newWorld.deactivateCell(x + xOffset, y + yOffset);
					break;
				// Cell does not change
				case 2:
					break;
				// Cell is Active					
				case 3:
					newWorld.activateCell(x + xOffset, y + yOffset);
					break;
				// Cell does not change
				default:
					break;
				}												
			}
		}
	}


	@Override
	public void mouseClicked(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}		
	
}
