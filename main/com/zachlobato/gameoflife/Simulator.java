package com.zachlobato.gameoflife;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.JApplet;

public class Simulator extends JApplet implements MouseListener {

	private static final long serialVersionUID = 817526540227405637L;
	Image backBuffer;
	Graphics backg;
	
	Timer timer;
	TimerTask task;
	World world;
	private World emptyWorld;
	
	private class MyTimerTask extends TimerTask{
		/**
		 * The main loop of the program. Causes new worlds to be
		 * generated.
		 */
		public void run(){
			world = simulateGeneration(world);
			repaint();
		}
	}
	
	/**
	 * Initializes global variables for application. Only executed once
	 * during simulation.
	 */
	public void init(){				
		// Worlds (States)
		world = generatesSeedWorld();
		emptyWorld = new World(new Coordinate(0,0), 1,1);
		
		// Drawing support
		backBuffer = createImage(this.getWidth(), this.getHeight());
		backg = backBuffer.getGraphics();
		
		// Support for mouse events
		this.addMouseListener(this);		
		
		// Simulation clock
		timer = new Timer();
		task = new MyTimerTask();
		timer.schedule(task, 0, 64);
	}
	
	/**
	 * A part of the JApplet, overriding allows for 
	 * backbuffering.
	 */
	public void paint(Graphics g){
		update(g);
	}
	
	/**
	 * Allows for backbuffer with backg.
	 */
	public void update(Graphics g){
		g.drawImage(backBuffer, 0, 0, this);
		clearScreen(backg, Color.WHITE);		
		world.drawWorld(g);
	}
	
	/**
	 * Clears a JApplet window with the specified color.
	 * 
	 * @param g
	 * @param screenColor
	 */
	private void clearScreen(Graphics g, Color screenColor){
		g.setColor(screenColor);
		g.fillRect(0, 0, this.getWidth(), this.getHeight());
	}

	/**
	 * Generates a seed world with which to start the simulation.
	 * 
	 * @return World - Seed world
	 */
	protected World generatesSeedWorld() {
		// createRandomSizedWorld	
		// populateWorldWithCells
		
		World staticWorld;
		
		// SHORT LIVED
//		staticWorld = new World(new Coordinate(0,0), 3, 3);		
//		staticWorld.activateCell(1, 1);
		
		// SIMPLE REPEAT
//		staticWorld = new World(new Coordinate(5,5), 5, 3);		
//		staticWorld.activateCell(1, 1);
//		staticWorld.activateCell(2, 1);
//		staticWorld.activateCell(3, 1);
		
		// INFINITE GROWTH
		staticWorld = new World(new Coordinate(0,0), 10, 8);
		staticWorld.activateCell(1, 6);
		
		staticWorld.activateCell(3, 5);
		staticWorld.activateCell(3, 6);
		
		staticWorld.activateCell(5, 2);
		staticWorld.activateCell(5, 3);
		staticWorld.activateCell(5, 4);
		
		staticWorld.activateCell(7, 1);
		staticWorld.activateCell(7, 2);
		staticWorld.activateCell(7, 3);
		
		staticWorld.activateCell(8, 2);
				
		return staticWorld;
	}

	/**
	 * Runs simulation through a single generation.
	 * 
	 * @param oldWorld - the old world
	 * @return World - the next generation of the world
	 */
	protected World simulateGeneration(World oldWorld) {
		
		if (oldWorld.width < 3 || oldWorld.height < 3)
			return this.emptyWorld;
		
		// createReplacementWorld
		World newWorld = createReplacementWorld(oldWorld);
		
		// populateReplacementWorldGeneration
		populateReplacementWorld(oldWorld, newWorld);
		
		// contractWorld		
		newWorld.contractWorld();
		
		return newWorld;
	}

	/**
	 * Generates a new empty replacement world of the correct (expanded if necessary)
	 * size based on the oldWorld. This will be used to populate the next generation
	 * of cells.
	 * 
	 * @param oldWorld
	 * @return
	 */
	public World createReplacementWorld(World oldWorld) {
		boolean topExpands, bottomExpands, leftExpands, rightExpands;
		topExpands = bottomExpands = leftExpands = rightExpands = false;	
		
		// Check top row
		// Check bottom row		
		for (int x = 0; x < oldWorld.width; x++){
			if (oldWorld.getActiveNeighbors(x, 0)==3){
				topExpands = true;
			}
			if (oldWorld.getActiveNeighbors(x, oldWorld.height-1)==3){
				bottomExpands = true;
			}
		}
		
		// Check left column		
		// Check right column
		for (int y = 0; y < oldWorld.height; y++){
			if (oldWorld.getActiveNeighbors(0, y)==3){
				leftExpands = true;
			}
			if (oldWorld.getActiveNeighbors(oldWorld.width-1, y)==3){
				rightExpands = true;
			}
		}
		
		Coordinate newTopLeft = new Coordinate(oldWorld.topLeft.x, oldWorld.topLeft.y);
		int newWidth = oldWorld.width;
		int newHeight = oldWorld.height;
		
		if (topExpands){
			newTopLeft.y += 1;
			newHeight += 1;
		}
		if (bottomExpands){
			newHeight += 1;
		}
		if (leftExpands){
			newTopLeft.x -= 1;
			newWidth += 1;
		}
		if (rightExpands){
			newWidth += 1;
		}
		
		return new World(newTopLeft, newWidth, newHeight);
	}

	/**
	 * Takes a world generated by createReplacementWorld and populates it
	 * with the oldWorld's nextGeneration of values.
	 * 
	 * @param oldWorld
	 * @param newWorld
	 */
	public void populateReplacementWorld(World oldWorld, World newWorld) {
		int xOffset = oldWorld.topLeft.x -  newWorld.topLeft.x;
		int yOffset = newWorld.topLeft.y - oldWorld.topLeft.y;
		
		int neighborCount = 0;
		for (int x = 0; x < oldWorld.width; x++){
			for (int y = 0; y < oldWorld.height; y++){
				newWorld.setCellValue(x + xOffset, y + yOffset, oldWorld.getCellValue(x,y));
								
				neighborCount = oldWorld.getActiveNeighbors(x, y);
				
				switch (neighborCount) {
				// Cell Inactive
				case 0:
				case 1:
					newWorld.deactivateCell(x + xOffset, y + yOffset);
					break;
				// Cell does not change
				case 2:
					break;
				// Cell is Active					
				case 3:
					newWorld.activateCell(x + xOffset, y + yOffset);
					break;
				// Cell dies not change
				default:
					newWorld.deactivateCell(x + xOffset,  y + yOffset);
					break;
				}												
			}
		}
	}


	@Override
	public void mouseClicked(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}
	
}
